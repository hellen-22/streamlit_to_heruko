# -*- coding: utf-8 -*-
"""Student Grade Predictions.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1mfTWPsV87zEw4lVkMI_wJiJmDVgjoxJF

# DATA COLLECTION
"""

from google.colab import files

# Commented out IPython magic to ensure Python compatibility.
import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
import seaborn as sns

# %matplotlib inline

import warnings
warnings.filterwarnings("ignore")

import plotly as py
import plotly.graph_objs as go
import plotly.express as px
from plotly.offline import download_plotlyjs, plot, init_notebook_mode, iplot

"""## Importing modules"""

student_data = files.upload()

student_data = pd.read_csv("student-mat.csv")
student_data.head()

student_data.tail()

student_data.shape

student_data.info()

student_data.describe()

student_data.columns

"""# DATA CLEANING"""

student_data.isnull().values.any()

student_data.isnull().sum()

"""# FEATURE ENGINEERING"""

import warnings

warnings.simplefilter(action='ignore', category=FutureWarning)

average = (student_data["G1"] + student_data["G2"] + student_data["G3"]) / 3

grades = []

for row in average:
    if row > 15 and row <= 20:
        grades.append("A")
    elif row > 8 and row <= 15:
        grades.append("B")
    elif row >= 0 and row <= 8:
        grades.append("C")

student_data["average"] = average

student_data["grades"] = grades

student_data

student_data.describe()

student_data.plot(kind="box",figsize=(15,9));

Q1 = student_data.quantile(0.25)
Q3 = student_data.quantile(0.75)
IQR = Q3 - Q1
outliers = (student_data < (Q1 - 1.5 * IQR)) | (student_data > (Q3 + 1.5 * IQR))

final1 = student_data[~(outliers).any(axis=1)]
final1.plot(kind="box",figsize=(15,9));

Q1 = final1.quantile(0.25)
Q3 = final1.quantile(0.75)
IQR = Q3 - Q1
outliers = (final1 < (Q1 - 1.5 * IQR)) | (final1 > (Q3 + 1.5 * IQR))

final2 = final1[~(outliers).any(axis=1)]
final2.plot(kind="box",figsize=(15,10))

Q1 = final2.quantile(0.25)
Q3 = final2.quantile(0.75)
IQR = Q3 - Q1
outliers = (final2 < (Q1 - 1.5 * IQR)) | (final2 > (Q3 + 1.5 * IQR))

final3 = final2[~(outliers).any(axis=1)]
final3.plot(kind="box",figsize=(15,10))

Q1 = final3.quantile(0.25)
Q3 = final3.quantile(0.75)
IQR = Q3 - Q1
outliers = (final3 < (Q1 - 1.5 * IQR)) | (final3 > (Q3 + 1.5 * IQR))

final_data = final3[~(outliers).any(axis=1)]
final_data.plot(kind="box",figsize=(15,10))

final_data

categorical_columns = []
numerical_columns = []

for col in student_data.columns :
    if student_data[col].dtype == "object":
        categorical_columns.append(col)
    elif (student_data[col].dtype == "int64") | (student_data[col].dtype == "float"):
        numerical_columns.append(col)
        
numerical_columns

"""### Numerical columns
1. Age - students age
2. Medu - mother's education
3. Fedu - father's education
4. Travel time - time of travelling from home to school
5. Study time - time used in studying
6. Failures - number of failures
7. Famrel - family relationship
8. Free time - student's free time
9. Goout - going out
10. Dalc - weekday alcohol consumption
11. Walc - weekend alcohol consumption
12. Health - health status
13. Absences - school absences
14. G1 - first grade
15. G2 - second grade
16. G3 - final grade
"""

for feature in categorical_columns:
    print(feature,"=",student_data[feature].unique())

"""### Categorical columns
1. School - Gabriel Pereira(GP) , Mousinho da Silveira(MS)
2. Sex - Female (F), Male (M)
3. Address - Urban (U), Rural (R)
4. Famsize - Family size : Greater than 3, Less than or equal to 3 (LE3)
5. Pstatus - Parent Marital Status : Apart (A), Together(T)
6. Mjob - Mother's job
7. Fjob - Father's job
8. Reason - Reason for choosing the school
9. Guardian - who the guardian is.
10. Schoolsup - School's support
11. Famsup - Family's support
12. Paid - Extra classes
13. Activities - Extra curriculum activities
14. Nursery - Attended nursery school
15. Higher - If they want to take higher education.
16. Internet - Internet access
17. Romantic - In a romantic relationship

### LABEL ENCODING
"""

from sklearn.preprocessing import LabelEncoder

label = LabelEncoder()
final_label_data = final_data.copy()

for col in categorical_columns:
    final_label_data[col] = label.fit_transform(final_data[col])
    
final_label_data.head()

final_label_data.describe()

"""# BUILDING MODEL

## Importing modules
"""

from sklearn.model_selection import train_test_split
from sklearn import tree
from sklearn.svm import SVC
from sklearn.neighbors import KNeighborsClassifier
from sklearn.naive_bayes import GaussianNB
from sklearn.metrics import accuracy_score, mean_absolute_error

X_features = ["school", "sex", "age", "address", "famsize", "Medu", "Fedu", "traveltime", "studytime", "famsup", "activities", "higher", "romantic", "famrel", "freetime"]
X = final_label_data[X_features]

y_features = ["grades"]
y = final_label_data[y_features]
y

X_train, X_test, y_train, y_test = train_test_split(X, y, random_state=0)

classifiers = {
    'K Nearest Neighbors' : KNeighborsClassifier(),
    'Decision Tree Classifier': tree.DecisionTreeClassifier(random_state=1),
    
    'SVM': SVC(random_state=1),
    'Naive Bayes': GaussianNB(),
}

accuracies = []
means = []
for key, clf in classifiers.items() :
    
    clf.fit(X_train, y_train.values.ravel())
    prediction = clf.predict(X_test)
    
    accuracy = accuracy_score(prediction, y_test)
    accuracies.append(accuracy)
    print("The accuracy of ", key, "is ",accuracy)
    
    MEA = mean_absolute_error(prediction, y_test)
    means.append(MEA)
    print("The MEA of ", key, "is ",MEA)

indexes = ["K Nearest Neighbors", "Decision Tree Classifier", "SVM", "Naive Bayes"]
data = accuracies
performance = pd.DataFrame(data=data, index=indexes, columns=["accuracy"])
performance["MEA"] = means
performance

model = classifiers.get("K Nearest Neighbors")

prediction = model.predict(X)
prediction

import pickle 
pickle_out = open("classifier.pkl", mode = "wb") 
pickle.dump(model, pickle_out) 
pickle_out.close()

!pip install -q pyngrok

!pip install -q streamlit

!pip install -q streamlit_ace

import streamlit

import streamlit
print(streamlit.__version__)

# Commented out IPython magic to ensure Python compatibility.
# %%writefile app.py
#  
# import pickle
# import streamlit as st
#  
# # loading the trained model
# pickle_in = open('classifier.pkl', 'rb') 
# classifier = pickle.load(pickle_in)
#  
# @st.cache()
# 
#   
# # defining the function which will make the prediction using the data which the user inputs 
# def prediction(school, sex, age, address, famsize, Medu, Fedu, traveltime, studytime, famsup, activities, higher, romantic, famrel, freetime):   
#  
#     # Pre-processing user input    
#     if school == "GP":
#         school = 0
#     else:
#         school = 1
#  
#     if sex == "F":
#         sex = 0
#     else:
#         sex = 1
# 
#     if address == "U":
#         address = 0
#     else:
#         address = 1  
# 
#     if famsize == "GT3":
#         famsize = 0
#     else:
#         famsize = 1 
# 
#     if famsup == "no":
#         famsup = 0
#     else:
#         famsup = 1
# 
#     if activities == "no":
#         activities = 0
#     else:
#         activities = 1  
# 
#     if higher == "yes":
#         higher = 0
#     else:
#         higher = 1
# 
#     if romantic == "no":
#         romantic = 0
#     else:
#         romantic = 1
#   
#     # Making predictions 
#     prediction = classifier.predict( 
#         [[school, sex, age, address, famsize, Medu, Fedu, traveltime, studytime, famsup, activities, higher, romantic, famrel, freetime]])
#      
#     if prediction == 0:
#       pred = 'A'
#     elif prediction == 1:
#       pred = 'B'
#     else:
#       pred = 'C'
# 
#     return pred
#       
#   
# # this is the main function in which we define our webpage  
# def main():       
#     # front end elements of the web page 
#     html_temp = """ 
#     <div style ="background-color:pink;padding:13px"> 
#     <h1 style ="color:black;text-align:center;">Student grade prediction web app</h1> 
#     </div> 
#     """
#       
#     # display the front end aspect
#     st.markdown(html_temp, unsafe_allow_html = True) 
#       
#     # following lines create boxes in which user can enter data required to make prediction 
#     school = st.selectbox('School',("GP","MS"))
#     sex = st.selectbox('Gender',("Male","Female")) 
#     age = st.number_input("Age")
#     address = st.selectbox('Address',("Urban","Rural")) 
#     famsize = st.selectbox('Family size',("GT3", "LE3"))
#     Medu =st.number_input("Mother's education")
#     Fedu =st.number_input("Father's education")
#     traveltime = st.number_input("traveltime")
#     studytime = st.number_input("studytime")
#     famsup = st.selectbox('Family support',("yes","no"))
#     activities = st.selectbox('activities',("no","yes"))
#     higher = st.selectbox('Higher education',("no","yes"))
#     romantic = st.selectbox('Romantic relationship',("no","yes"))
#     famrel = st.number_input("Familyrelationship")
#     freetime = st.number_input("Free time")
#     result =""
#       
#     # when 'Predict' is clicked, make the prediction and store it 
#     if st.button("Predict"): 
#         result = prediction(school, sex, age, address, famsize, Medu, Fedu, traveltime, studytime, famsup, activities, higher, romantic, famrel, freetime) 
#         st.success('Your grade is {}'.format(result))
#       
#      
# if __name__=='__main__': 
#     main()

!streamlit run app.py &>/dev/null&

from pyngrok import ngrok
 
public_url = ngrok.connect('8501')
public_url